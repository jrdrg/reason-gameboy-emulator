exception AssertionException(string);

/* 256 bytes */
let bios =
  {|
    0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26, 0xFF, 0x0E,
    0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77, 0x77, 0x3E, 0xFC, 0xE0,
    0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95, 0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B,
    0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06, 0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9,
    0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21, 0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20,
    0xF9, 0x2E, 0x0F, 0x18, 0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04,
    0x1E, 0x02, 0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
    0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64, 0x20, 0x06,
    0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xF2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15, 0x20, 0xD2, 0x05, 0x20,
    0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB, 0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17,
    0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9, 0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B,
    0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E,
    0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3c, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x4C,
    0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x20, 0xFE, 0x23, 0x7D, 0xFE, 0x34, 0x20,
    0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x20, 0xFE, 0x3E, 0x01, 0xE0, 0x50
  |}
  |> Js.String.split(",")
  |> Array.map(Js.String.trim)
  |> Array.map(int_of_string);

type t = {
  finishedBios: bool,
  cartType: int,
  rom: array(int),
  externalRam: array(int),
  workRam: array(int),
  zeroPageRam: array(int),
};

type state = {
  gpu: Gpu.t,
  mmu: t,
};

let reset = mmu => {
  ...mmu,
  finishedBios: false,
  externalRam: Array.make(8192, 0),
  workRam: Array.make(8192, 0),
  zeroPageRam: Array.make(128, 0),
};

let load = bytes => {
  let mmu = {
    finishedBios: false,
    cartType: bytes[0x147], /* from docs - http://gameboy.mongenel.com/dmg/asmmemmap.html */
    rom: bytes,
    externalRam: [||],
    workRam: [||],
    zeroPageRam: [||],
  };
  reset(mmu);
};

let read8 = (addr, {mmu, gpu}: state) =>
  /* switch on the first byte */
  switch (addr land 0xf000) {
  | 0x0000 =>
    switch (mmu.finishedBios, addr <= 0xff, addr === 0x100) {
    | (false, true, _) => (bios[addr], mmu)
    | (false, _, true) =>
      Js.log("Loaded BIOS");
      /* Returns a tuple of (value, MMU) to persist the finishedBios flag */
      (mmu.rom[addr], {...mmu, finishedBios: true});
    | (true, _, _) => (mmu.rom[addr], mmu)
    | _ => (mmu.rom[addr], mmu)
    }
  | 0x1000
  | 0x2000
  | 0x3000 => (mmu.rom[addr], mmu)
  | 0x4000
  | 0x5000
  | 0x6000
  | 0x7000 => (mmu.rom[addr], mmu) /* ROM bank from cartridge */
  | 0x8000
  | 0x9000 => (gpu.vram[addr land 0x1fff], mmu) /* Video RAM */
  | 0xA000
  | 0xB000 => (0, mmu) /* External RAM */
  /*
    Work RAM
    This removes the first nibble of the address
    0xC000 + 0x1fff = 0xDFFF
    <addr> & 0x1fff means that Cxxx & Dxxx are the same as Exxx & Fxxx
   */
  | 0xC000
  | 0xD000
  | 0xE000 => (mmu.workRam[addr land 0x1fff], mmu)
  | 0xF000 =>
    switch (addr land 0x0f00) {
    | 0xE00 => (0, mmu) /* OAM */
    | 0xF00 =>
      switch (addr) {
      | a when a >= 0xFF80 => (mmu.zeroPageRam[addr land 0x7f], mmu)
      | _ =>
        switch (addr land 0x00f0) {
        | 0x40
        | 0x50
        | 0x60
        | 0x70 => (Gpu.read8(gpu), mmu)
        | _ => (0, mmu)
        }
      }
    | _ => (mmu.workRam[addr land 0x1fff], mmu) /* same as Work RAM above */
    }
  | _ => (0, mmu)
  };

/*
     Read one byte then the next byte left shifted by 8 bits
     It's little-endian, i.e.
     0x34, 0x12
     0x34 + (0x12 << 8) = 0x1234
 */
let read16 = (addr, {gpu} as state: state) => {
  let (a, mmu) = read8(addr, state);
  let (b, mmu) = read8(addr + 1, {gpu, mmu});
  let c = b lsl 8;
  (a + c, mmu);
};

let write8 = (addr, v, {gpu, mmu}: state) => {
  if (v > 0xff) {
    raise(AssertionException(Printf.sprintf("Write8: %x %x", addr, v)));
  };
  /* let {mmu, gpu} = state; */
  // Js.log(Printf.sprintf("Writing %x to addr %x", v, addr));
  switch (addr land 0xf000) {
  /* | 0x0000 | 0x1000  => */
  | 0x6000
  | 0x7000 =>
    /* select memory model to use - 0: 16/8 mode, 1: 4/32 mode */
    let mode = v land 0x1;
    (mmu, gpu);
  | 0x8000
  | 0x9000 =>
    gpu.vram[addr land 0x1fff] = v;
    Gpu.updateTile(addr, gpu);
    (mmu, gpu);
  | 0xC000
  | 0xD000
  | 0xE000 =>
    mmu.workRam[addr land 0x1fff] = v;
    (mmu, gpu);
  | _ => (mmu, gpu)
  };
};

let write16 = (addr, v, s: state) => {
  if (v > 0xffff) {
    raise(AssertionException(Printf.sprintf("Write16: %x %x", addr, v)));
  };

  let (mmu, gpu) = write8(addr, v land 0xff, s);
  let (mmu, gpu) = write8(addr + 1, v lsr 8, {mmu, gpu});

  (mmu, gpu);
};
